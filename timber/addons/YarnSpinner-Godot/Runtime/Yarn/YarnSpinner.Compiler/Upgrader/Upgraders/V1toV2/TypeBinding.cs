// Copyright Yarn Spinner Pty Ltd
// Licensed under the MIT License. See LICENSE.md in project root for license information.

namespace Yarn.Compiler.Upgrader
{
    using System.Collections.Generic;
    using System.Linq;

    /// <summary>
    /// Stores information about a relationship between a variable and its
    /// type.
    /// </summary>
    /// <remarks>
    /// This type is generated by classes such as <see
    /// cref="VariableDeclarationUpgrader.VariableTypeBindingVisitor"/>.
    /// It's possible for multiple type bindings for a single variable may
    /// exist, such as in cases where a variable is being used as a string
    /// and a number. This is syntactically valid, but semantically an
    /// error; to detect cases like this, users of this class should gather
    /// every possible binding they can find for a variable, and then call
    /// <see cref="UnifyBindings(IEnumerable{TypeBinding})"/>.
    /// </remarks>
    internal struct TypeBinding
    {
        public string VariableName;
        public Yarn.IType Type;

        public override bool Equals(object obj)
        {
            return obj is TypeBinding binding &&
                    this.VariableName == binding.VariableName &&
                    this.Type == binding.Type;
        }

        public override int GetHashCode()
        {
            int hashCode = 2098139523;
            hashCode = (hashCode * -1521134295) + EqualityComparer<string>.Default.GetHashCode(this.VariableName);
            if (Type != null)
            {
                hashCode = (hashCode * -1521134295) + this.Type.GetHashCode();
            }

            return hashCode;
        }

        public override string ToString()
        {
            return $"{this.VariableName}: {this.Type}";
        }

        public static List<TypeBinding> UnifyBindings(IEnumerable<TypeBinding> typeBindings)
        {
            // For each variable, decide whether we know its type (we have
            // 1 binding that is not 'undefined'), or we don't (any other
            // case).

            // Start by grouping all variables by their variable name.
            var variableBindingTypeGroups = typeBindings.GroupBy(b => b.VariableName, b => b);

            var unifiedVariableBindings = variableBindingTypeGroups.Select(bindingGroup =>
            {
                // If there is precisely one type binding, keep it, if it's
                // defined
                var definedBindings = bindingGroup.Where(b => b.Type != BuiltinTypes.Undefined);

                if (definedBindings.Count() == 1)
                {
                    return definedBindings.First();
                }

                // Otherwise, this type is undefined, because either it has
                // too many defined bindings, or only has an undefined
                // binding
                return new TypeBinding { VariableName = bindingGroup.Key, Type = BuiltinTypes.Undefined };
            }).ToList();

            return unifiedVariableBindings;
        }
    }
}
